<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NovelAI Ïù¥ÎØ∏ÏßÄ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Î∑∞Ïñ¥</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            padding: 20px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        h1 {
            margin-bottom: 20px;
            color: #fff;
        }
        .info-banner {
            background: #2a4a2a;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #4a9eff;
        }
        .info-banner strong {
            color: #4a9eff;
        }
        .controls {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .file-input-wrapper {
            margin-bottom: 15px;
        }
        input[type="file"] {
            display: block;
            padding: 10px;
            background: #3a3a3a;
            border: 2px dashed #555;
            border-radius: 4px;
            color: #e0e0e0;
            width: 100%;
            cursor: pointer;
        }
        input[type="file"]::-webkit-file-upload-button {
            background: #4a9eff;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
        }
        .filter-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        button {
            padding: 10px 20px;
            background: #4a9eff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }
        button:hover {
            background: #357abd;
        }
        button.active {
            background: #2d5a8f;
        }
        .image-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
            gap: 20px;
        }
        .image-card {
            background: #2a2a2a;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        .image-preview {
            width: 100%;
            height: 300px;
            object-fit: contain;
            background: #1a1a1a;
        }
        .metadata-section {
            padding: 15px;
        }
        .filename {
            font-weight: bold;
            margin-bottom: 10px;
            color: #4a9eff;
            word-break: break-all;
        }
        .extraction-method {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            margin-bottom: 10px;
        }
        .method-standard {
            background: #2a5a2a;
            color: #8f8;
        }
        .method-steganography {
            background: #5a2a5a;
            color: #f8f;
        }
        .metadata-content {
            max-height: 400px;
            overflow-y: auto;
            background: #1a1a1a;
            padding: 10px;
            border-radius: 4px;
            font-size: 13px;
        }
        .metadata-item {
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #3a3a3a;
        }
        .metadata-item:last-child {
            border-bottom: none;
        }
        .metadata-key {
            color: #ff9a56;
            font-weight: bold;
            margin-bottom: 4px;
        }
        .metadata-value {
            color: #e0e0e0;
            white-space: pre-wrap;
            word-break: break-word;
        }
        .no-metadata {
            color: #888;
            font-style: italic;
        }
        .stats {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        .stat-item {
            color: #e0e0e0;
        }
        .stat-value {
            color: #4a9eff;
            font-weight: bold;
        }
        .loading {
            text-align: center;
            padding: 20px;
            color: #4a9eff;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>NovelAI Ïù¥ÎØ∏ÏßÄ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Î∑∞Ïñ¥</h1>
        
        <div class="controls">
            <div class="file-input-wrapper">
                <input type="file" id="fileInput" accept="image/jpeg,image/jpg,image/png" multiple>
            </div>
            <div class="filter-buttons">
                <button id="showAll" class="active">Ï†ÑÏ≤¥ Î≥¥Í∏∞</button>
                <button id="showNovelAI">NovelAI Ïù¥ÎØ∏ÏßÄÎßå</button>
                <button id="showSteganography">Ïà®Í≤®ÏßÑ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞Îßå</button>
            </div>
        </div>

        <div class="stats" id="stats" style="display: none;">
            <div class="stat-item">
                Ï†ÑÏ≤¥: <span class="stat-value" id="totalCount">0</span>Í∞ú
            </div>
            <div class="stat-item">
                NovelAI: <span class="stat-value" id="novelaiCount">0</span>Í∞ú
            </div>
            <div class="stat-item">
                Ïà®Í≤®ÏßÑ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞: <span class="stat-value" id="steganographyCount">0</span>Í∞ú
            </div>
            <div class="stat-item">
                ÌëúÏãú Ï§ë: <span class="stat-value" id="displayCount">0</span>Í∞ú
            </div>
        </div>

        <div class="image-grid" id="imageGrid"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <script>
        let allImages = [];
        let currentFilter = 'all';

        const fileInput = document.getElementById('fileInput');
        const imageGrid = document.getElementById('imageGrid');
        const showAllBtn = document.getElementById('showAll');
        const showNovelAIBtn = document.getElementById('showNovelAI');
        const showSteganographyBtn = document.getElementById('showSteganography');
        const statsDiv = document.getElementById('stats');

        fileInput.addEventListener('change', handleFiles);
        showAllBtn.addEventListener('click', () => setFilter('all'));
        showNovelAIBtn.addEventListener('click', () => setFilter('novelai'));
        showSteganographyBtn.addEventListener('click', () => setFilter('steganography'));

        async function handleFiles(e) {
            const files = Array.from(e.target.files);
            allImages = [];
            
            imageGrid.innerHTML = '<div class="loading">Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú Ï§ë...</div>';
            
            for (const file of files) {
                const metadata = await extractMetadata(file);
                const imageUrl = URL.createObjectURL(file);
                allImages.push({
                    file,
                    imageUrl,
                    metadata: metadata.data,
                    extractionMethod: metadata.method,
                    isNovelAI: checkNovelAI(metadata.data),
                    hasSteganography: metadata.method === 'steganography'
                });
            }
            
            updateStats();
            renderImages();
        }

        function checkNovelAI(metadata) {
            const searchText = JSON.stringify(metadata).toLowerCase();
            return searchText.includes('prompt') || 
                   searchText.includes('description') || 
                   searchText.includes('novelai') ||
                   searchText.includes('steps') ||
                   searchText.includes('sampler');
        }

        async function extractMetadata(file) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = async function(e) {
                    const arr = new Uint8Array(e.target.result);
                    let metadata = {};
                    let method = 'none';

                    if (file.type === 'image/png') {
                        // Try standard PNG metadata first
                        metadata = extractPNGMetadata(arr);
                        if (Object.keys(metadata).length > 0) {
                            method = 'standard';
                        } else {
                            // Try steganography extraction
                            const hiddenData = await extractSteganographicData(arr);
                            if (hiddenData) {
                                metadata = hiddenData;
                                method = 'steganography';
                            }
                        }
                    } else if (file.type === 'image/jpeg' || file.type === 'image/jpg') {
                        metadata = extractJPEGMetadata(arr);
                        method = Object.keys(metadata).length > 0 ? 'standard' : 'none';
                    }

                    resolve({ data: metadata, method });
                };
                reader.readAsArrayBuffer(file);
            });
        }

        function extractPNGMetadata(arr) {
            const metadata = {};
            let pos = 8;
            
            while (pos < arr.length) {
                const length = (arr[pos] << 24) | (arr[pos+1] << 16) | (arr[pos+2] << 8) | arr[pos+3];
                const type = String.fromCharCode(arr[pos+4], arr[pos+5], arr[pos+6], arr[pos+7]);
                
                if (type === 'tEXt' || type === 'iTXt' || type === 'zTXt') {
                    const chunkData = arr.slice(pos + 8, pos + 8 + length);
                    
                    let keyEnd = 0;
                    while (keyEnd < chunkData.length && chunkData[keyEnd] !== 0) keyEnd++;
                    
                    const key = new TextDecoder().decode(chunkData.slice(0, keyEnd));
                    
                    if (type === 'tEXt') {
                        const value = new TextDecoder().decode(chunkData.slice(keyEnd + 1));
                        metadata[key] = value;
                    } else if (type === 'iTXt') {
                        let offset = keyEnd + 1;
                        const compressionFlag = chunkData[offset++];
                        const compressionMethod = chunkData[offset++];
                        
                        let langEnd = offset;
                        while (langEnd < chunkData.length && chunkData[langEnd] !== 0) langEnd++;
                        offset = langEnd + 1;
                        
                        let transEnd = offset;
                        while (transEnd < chunkData.length && chunkData[transEnd] !== 0) transEnd++;
                        offset = transEnd + 1;
                        
                        const value = new TextDecoder().decode(chunkData.slice(offset));
                        metadata[key] = value;
                    }
                }
                
                if (type === 'IEND') break;
                pos += 12 + length;
            }
            
            return metadata;
        }

        async function extractSteganographicData(pngData) {
            try {
                // Load image to canvas
                const blob = new Blob([pngData], { type: 'image/png' });
                const img = await createImageBitmap(blob);
                
                // Check size limit (similar to original code: 16777216 pixels = 4096x4096)
                if (img.width * img.height > 16777216) {
                    return null;
                }
                
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                
                // Extract LSB from alpha channel
                const imageData = ctx.getImageData(0, 0, img.width, img.height);
                const alphaLSBs = [];
                
                for (let i = 3; i < imageData.data.length; i += 4) {
                    alphaLSBs.push(imageData.data[i] & 1);
                }
                
                // Read header to check if it's steganographic data
                let bitPos = 0;
                
                function readByte() {
                    let byte = 0;
                    for (let i = 0; i < 8; i++) {
                        const rowIndex = Math.floor(bitPos / img.height);
                        const colIndex = bitPos % img.height;
                        byte |= alphaLSBs[colIndex * img.width + rowIndex] << (7 - i);
                        bitPos++;
                    }
                    return byte;
                }
                
                // Check for magic header "stealth_pngcomp"
                const header = [];
                for (let i = 0; i < 15; i++) {
                    header.push(readByte());
                }
                
                const headerStr = String.fromCharCode(...header);
                if (headerStr !== 'stealth_pngcomp') {
                    return null;
                }
                
                // Read data length (4 bytes, big-endian)
                const lengthBytes = [];
                for (let i = 0; i < 4; i++) {
                    lengthBytes.push(readByte());
                }
                const dataLength = (lengthBytes[0] << 24) | (lengthBytes[1] << 16) | 
                                  (lengthBytes[2] << 8) | lengthBytes[3];
                
                // Read compressed data
                const compressedData = [];
                for (let i = 0; i < dataLength / 8; i++) {
                    compressedData.push(readByte());
                }
                
                // Decompress using pako
                const compressedUint8 = new Uint8Array(compressedData);
                
                let jsonStr;
                try {
                    // First try to decompress with pako
                    if (typeof pako !== 'undefined') {
                        try {
                            const decompressed = pako.inflate(compressedUint8);
                            jsonStr = new TextDecoder().decode(decompressed);
                        } catch (pakoError) {
                            // If pako fails, try direct decode (might not be compressed)
                            console.log('Pako decompression failed, trying direct decode:', pakoError);
                            jsonStr = new TextDecoder().decode(compressedUint8);
                        }
                    } else {
                        // Pako not available, try direct decode
                        jsonStr = new TextDecoder().decode(compressedUint8);
                    }
                    
                    // Parse and return JSON
                    return JSON.parse(jsonStr);
                    
                } catch (error) {
                    console.error('Failed to parse steganographic data:', error);
                    return null;
                }
                
            } catch (error) {
                console.error('Steganography extraction error:', error);
                return null;
            }
        }

        function extractJPEGMetadata(arr) {
            const metadata = {};
            let pos = 2;
            
            while (pos < arr.length) {
                if (arr[pos] !== 0xFF) break;
                
                const marker = arr[pos + 1];
                pos += 2;
                
                if (marker === 0xD9 || marker === 0xDA) break;
                
                const segmentLength = (arr[pos] << 8) | arr[pos + 1];
                
                if (marker === 0xE1) {
                    const exifData = arr.slice(pos + 2, pos + segmentLength);
                    
                    if (String.fromCharCode(...exifData.slice(0, 4)) === 'Exif') {
                        parseEXIF(exifData.slice(6), metadata);
                    }
                } else if (marker === 0xFE) {
                    const comment = new TextDecoder().decode(arr.slice(pos + 2, pos + segmentLength));
                    metadata['Comment'] = comment;
                }
                
                pos += segmentLength;
            }
            
            return metadata;
        }

        function parseEXIF(data, metadata) {
            const view = new DataView(data.buffer, data.byteOffset, data.byteLength);
            
            const byteOrder = view.getUint16(0);
            const littleEndian = byteOrder === 0x4949;
            
            const ifdOffset = view.getUint32(4, littleEndian);
            parseIFD(view, ifdOffset, littleEndian, metadata);
        }

        function parseIFD(view, offset, littleEndian, metadata) {
            const tagCount = view.getUint16(offset, littleEndian);
            
            const exifTags = {
                0x010E: 'ImageDescription',
                0x010F: 'Make',
                0x0110: 'Model',
                0x0131: 'Software',
                0x013B: 'Artist',
                0x8298: 'Copyright',
                0x9286: 'UserComment'
            };
            
            for (let i = 0; i < tagCount; i++) {
                const entryOffset = offset + 2 + (i * 12);
                const tag = view.getUint16(entryOffset, littleEndian);
                const type = view.getUint16(entryOffset + 2, littleEndian);
                const count = view.getUint32(entryOffset + 4, littleEndian);
                const valueOffset = view.getUint32(entryOffset + 8, littleEndian);
                
                if (exifTags[tag]) {
                    try {
                        let value;
                        if (type === 2) {
                            if (count <= 4) {
                                value = String.fromCharCode(...new Uint8Array(view.buffer, view.byteOffset + entryOffset + 8, count - 1));
                            } else {
                                value = String.fromCharCode(...new Uint8Array(view.buffer, view.byteOffset + valueOffset, count - 1));
                            }
                        }
                        if (value && value.trim()) {
                            metadata[exifTags[tag]] = value;
                        }
                    } catch (e) {}
                }
            }
        }

        function setFilter(filter) {
            currentFilter = filter;
            showAllBtn.classList.toggle('active', filter === 'all');
            showNovelAIBtn.classList.toggle('active', filter === 'novelai');
            showSteganographyBtn.classList.toggle('active', filter === 'steganography');
            renderImages();
        }

        function updateStats() {
            const novelaiCount = allImages.filter(img => img.isNovelAI).length;
            const steganographyCount = allImages.filter(img => img.hasSteganography).length;
            document.getElementById('totalCount').textContent = allImages.length;
            document.getElementById('novelaiCount').textContent = novelaiCount;
            document.getElementById('steganographyCount').textContent = steganographyCount;
            statsDiv.style.display = allImages.length > 0 ? 'flex' : 'none';
        }

        function renderImages() {
            let filteredImages = allImages;
            
            if (currentFilter === 'novelai') {
                filteredImages = allImages.filter(img => img.isNovelAI);
            } else if (currentFilter === 'steganography') {
                filteredImages = allImages.filter(img => img.hasSteganography);
            }
            
            document.getElementById('displayCount').textContent = filteredImages.length;
            
            imageGrid.innerHTML = filteredImages.map((img, index) => {
                const methodBadge = img.extractionMethod === 'steganography' 
                    ? '<span class="extraction-method method-steganography">üîê Ïà®Í≤®ÏßÑ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞</span>'
                    : img.extractionMethod === 'standard'
                    ? '<span class="extraction-method method-standard">üìÑ ÌëúÏ§Ä Î©îÌÉÄÎç∞Ïù¥ÌÑ∞</span>'
                    : '';
                
                const metadataHtml = Object.keys(img.metadata).length > 0
                    ? Object.entries(img.metadata).map(([key, value]) => `
                        <div class="metadata-item">
                            <div class="metadata-key">${escapeHtml(key)}</div>
                            <div class="metadata-value">${escapeHtml(value)}</div>
                        </div>
                    `).join('')
                    : '<div class="no-metadata">Î©îÌÉÄÎç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§</div>';
                
                return `
                    <div class="image-card">
                        <img src="${img.imageUrl}" alt="${img.file.name}" class="image-preview">
                        <div class="metadata-section">
                            <div class="filename">${escapeHtml(img.file.name)}</div>
                            ${methodBadge}
                            <div class="metadata-content">
                                ${metadataHtml}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
    </script>
</body>
</html>

